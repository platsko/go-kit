// Copyright Â© 2020-2021 The EVEN Solutions Developers Team

package merkle

import (
	"math"

	"github.com/platsko/go-kit/crypto"
	"github.com/platsko/go-kit/errors"
)

const (
	// MinTreeStoreSize constant of the minimal possible size for a properly built
	// Merkle tree store in case the list contains of a single element.
	MinTreeStoreSize = 3
)

type (
	// TreeStore represents Merkle Tree Store.
	TreeStore []crypto.Hash256
)

// BuildTreeStore creates a merkle tree from a slice of hashes,
// stores it using a linear array, and returns a slice of the backing array.
//
// A merkle tree is a tree in which every non-leaf node is the hash of its
// children nodes.
//
// A diagram depicting how this works for transactions where h(x) is a sha256 follows:
//	         root = h1234 = h(h12 + h34)
//	        /                           \
//	  h12 = h(h1 + h2)            h34 = h(h3 + h4)
//	   /            \              /            \
//	h1 = h(tx1)  h2 = h(tx2)    h3 = h(tx3)  h4 = h(tx4)
//
// The above stored as a linear array is as follows:
// [h1 h2 h3 h4 h12 h34 root]
//
// As the above shows, the merkle root is always the last element in the array.
//
// The number of inputs is not always a power of two which results in a balanced
// tree structure as above.
// In that case, parent nodes with no children are also zero and parent nodes
// with only a single left node are calculated by concatenating the left node
// with itself before hashing.
// This function uses nodes that are pointers to the hashes, empty nodes will be nil.
func BuildTreeStore(iter Iterator) (TreeStore, error) { // nolint: cyclop
	if iter == nil {
		return nil, errors.ErrNilPointerValue()
	}

	// calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size
	nextPoT := iter.Len()
	if nextPoT == 0 { // zero size element lists
		return nil, errors.ErrZeroSizeValue()
	}

	if nextPoT == 1 || nextPoT&(nextPoT-1) != 0 { // the number is not a power of 2
		// figure out and calc the next power of two
		exponent := uint(math.Log2(float64(nextPoT))) + 1
		nextPoT = 1 << exponent // 2^exponent
	}

	size := nextPoT*2 - 1 // nolint: gomnd
	store := make(TreeStore, size)

	// create the base transaction hashes and populate the array with them
	for idx := 0; iter.HasNext(); idx++ {
		h256, err := iter.HasherNext().Hash()
		if err != nil {
			return nil, err
		}
		store[idx] = h256
	}

	// start offset after the last entry and adjusted to the next power of two
	for i, l, offset := 0, size-1, nextPoT; i < l; i, offset = i+2, offset+1 { // nolint: gomnd
		switch {
		// when there is no left child node, the parent is nil too
		case store[i].Empty():
			continue

		// when there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself
		case store[i+1].Empty():
			store[offset] = crypto.NewHash256(store[i][:], store[i][:])

		// default case sets the parent node to the sha256
		// of the concatenation of the left and right children
		default:
			store[offset] = crypto.NewHash256(store[i][:], store[i+1][:])
		}
	}

	return store, nil
}

// Root returns the merkle tree root hash.
func (m TreeStore) Root() (crypto.Hash256, error) {
	size := len(m)
	if size < MinTreeStoreSize {
		return crypto.Hash256{}, ErrMerkleTreeBuiltImproperly()
	}

	return m[size-1], nil
}
